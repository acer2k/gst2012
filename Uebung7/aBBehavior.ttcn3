/**
 * @desc This module contains the templates for your exercises. There are five excercises, to solve. 
 * If possible do not rename the test cases. But if you want you can of course create new test cases. in addition.
 * 
 */
module aBBehavior {
	import from aB all;
	import from aBConfig all;
	import from aBTemplates all;


	group testCases {

        /**
		 * @desc
		 *     This test case should check that addEntry works as expected. 
		 *     This means that no response shall be received within a given period of time
		 *     A timer shall be used to check this.
		 *     The verdict should be pass.
		 */
        testcase TC_addEntry_withTimer () runs on ClientComponent system AddressBookSystem {
            
            timer timeCounter := 6.0;
            
            map(self:sp, system:sp);
            
            initialClear();

            sp.send(tAddEntry(tFirstEntry));
          
            timeCounter.start;
            
            alt {
				
			
				[] timeCounter.timeout {
				    setverdict(pass);
				}
				[] sp.receive {
				    setverdict(fail);
				}
            }
        }		

        /**
		 * @desc
		 *     This test case checks if the System Under Test reports correctly
		 *     that a user already exists in the database.
		 *     For this you should 
		 *     	- first insert a message and then
		 *      - reinsert the same message and catch the response.
		 *      Guard all operations with timers
		 *     The verdict should be pass.
		 */
        testcase TC_addEntry_UserExists() runs on ClientComponent system AddressBookSystem {
            timer timeCounter1  := 6.0;
            timer timecounter2 := 12.0;
            var userExists rep;
            
            map(self:sp, system:sp);

            sp.send(clear_:{});
            setverdict(pass);
            
           
            sp.send(tAddEntry(tFirstEntry));
            log("SENDING FIRST MESSAGE");
                        
             
            timeCounter1.start;
            alt {
			
				[] sp.receive {
				    setverdict(fail);
				}
				[] timeCounter1.timeout {
				 	setverdict(pass);
				}
            }

            
            
            sp.send(tAddEntry(tFirstEntry)); 
            log("SENDING SECOND MESSAGE");
            
                        
            timecounter2.start;
            alt {

				[] sp.receive(rep) {
				    setverdict(pass);
				}
				[] sp.receive {
				    setverdict(fail);
				}
				[] timecounter2.timeout {
				    setverdict(inconc);
				}
            }
        }


		/**
		 * @desc This testcase shall find the maximum size of the addressBook.
		 * The way to test is could be to insert fresh entrys in a loop and to catch the sizeLimitReached message.
		 * We assume that the maximum size is below 10.
		 * The verdict should be pass. 
		 */
		testcase TC_addEntry_sizeLimitReached() runs on ClientComponent system AddressBookSystem {
            timer t := 3.0;
            var boolean stillNotFound := true;
            var integer i := 0;
            var sizeLimitReached rep;
            
			map(self:sp, system:sp);

			initialClear();

			do {
			    
				var charstring JohnDoe := int2str(float2int(rnd()*1000.0));
				sp.send(tAddEntry(tFlexEntry(SurName:JohnDoe, FirstName:JohnDoe)));

			
				t.start;
				alt {
				
					[] sp.receive(rep) {
					    stillNotFound := false;
					}
					[] sp.receive {
					   setverdict(fail);
					}
					[] t.timeout {
                       
					}
				}
			
				i := i + 1;
			} while (stillNotFound and i <= 12);

			if (stillNotFound) {
			    
			    log ("Limit not found!");
			    
			    setverdict(fail);
			
			}
			
			else {
			    
			    
                log("Limit is " & int2str(i));
				setverdict(pass);
			}
		}

		/**
		 * @desc
		 *     This test case tries to receive the contact information of a
		 *     database entry. The verdict should be pass.
		 *     
		 *     1. First we insert the a valid addressbook entry and then
		 *     2. We search for this entry and compare the email.
		 */
		testcase TC_getEntry_valid_Email() runs on ClientComponent system AddressBookSystem {
		    timer timeCounter1  := 6.0;
            timer timeCounter2 := 12.0;
		    var getEntryReply rep;

			map(mtc:sp, system:sp);
			initialClear();

		
			sp.send(tAddEntry(tFirstEntry));

			timeCounter1.start;
			alt {
		
				[] sp.receive {
				    setverdict(fail);
				}
				[] timeCounter1.timeout {
				    setverdict(pass);
				}
			}

		
			sp.send(tGetEntry(tFirstEntry.surName));

			timeCounter2.start;
			alt {
             
                [] sp.receive(rep) {
                    if (rep.contact.email == tFirstEntry.contact.email) {
                        setverdict(pass);
                    }
                    else {
                        setverdict(fail);
                    }
                }
                [] sp.receive {
                    setverdict(fail);
                }
                [] timeCounter2.timeout {
                    setverdict(inconc);
                }
			}
		}

		/**
		 * @desc This test cases tests that if the contact field is has a phonenumber
		 * 	the phone number has the correct value stored. 
		 *  
		 * The verdict should be pass in case the stored phone number is the correct one.
		 */
		testcase TC_getEntry_valid_phoneNumber() runs on ClientComponent system AddressBookSystem {
		    timer timeCounter1  := 6.0;
            timer timeCounter2 := 12.0;
            var getEntryReply rep;
            
			map(mtc:sp, system:sp);
			initialClear();

		
			sp.send(tAddEntry(tSecondEntry));
			timeCounter1.start;
			alt {
            
                [] sp.receive {
                    setverdict(fail);
                }
                [] timeCounter1.timeout {
                    setverdict(pass);
                }
			}

			
			sp.send(tGetEntry(tSecondEntry.surName));
			timeCounter2.start;
			alt {
             
			
                [] sp.receive(rep) {
                    if ( tSecondEntry.contact.number == rep.contact.number) {
                        setverdict(pass);
                    }
                    else {
                        setverdict(fail);
                    }
                }
                [] sp.receive {
                    setverdict(fail);
                }
                [] timeCounter2.timeout {
                    setverdict(inconc);
                }
			}
		}

	}

	group functions {
		/**
		 * @desc precondition to clear initially the database.
		 */
		function initialClear() runs on ClientComponent {
			sp.send(clear_:{});
			t1.start;
			alt {
				[] sp.receive {
					setverdict(inconc, "Received a message after a clear operation.");
				}
				[] t1.timeout {
					setverdict(pass, "Passed the clear operation.");
				}
			}
		}

	}

}